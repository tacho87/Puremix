<loader>
  async function loadResultChart(request, actionResult, props) {
    const prediction = props.prediction || null;
    const chartId = `chart_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Compute all formatted values in the loader
    let formattedData = {
      formattedPrice: 'N/A',
      formattedPricePerSqm: 'N/A',
      formattedLowerBound: 'N/A',
      formattedUpperBound: 'N/A',
      confidenceRange: 'N/A - N/A',
      priceLabel: 'unit',
      hasFeatureImportance: false,
      featureImportance: []
    };
    let styleData = {
      rangeLeft: '0%',
      rangeWidth: '100%'
    };

    if (prediction) {
      // Handle both direct prediction result and nested structure
      const predictedPrice = prediction.predicted_price || prediction.data?.predicted_price || 0;
      const pricePerSqm = prediction.price_per_sqm || prediction.data?.price_per_sqm || 0;
      const confidenceInterval = prediction.confidence_interval || prediction.data?.confidence_interval || { lower: 0, upper: 0 };
      const featureImportance = prediction.feature_importance || prediction.data?.feature_importance || {};

      const formatPrice = (price) => {
        if (typeof price !== 'number') return 'N/A';
        return price.toLocaleString('en-US', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
      };

      formattedData = {
        formattedPrice: formatPrice(predictedPrice),
        formattedPricePerSqm: formatPrice(pricePerSqm),
        formattedLowerBound: formatPrice(confidenceInterval.lower),
        formattedUpperBound: formatPrice(confidenceInterval.upper),
        confidenceRange: `${formatPrice(confidenceInterval.lower)} - ${formatPrice(confidenceInterval.upper)}`,
        priceLabel: prediction.property_details || prediction.property_details ? 'sqm' : 'unit',
        hasFeatureImportance: Object.keys(featureImportance).length > 0,
        featureImportance: []
      };

      // Compute style values as strings
      if (confidenceInterval.upper > 0) {
        const lowerPct = (confidenceInterval.lower / confidenceInterval.upper) * 100;
        const rangePct = ((confidenceInterval.upper - confidenceInterval.lower) / confidenceInterval.upper) * 100;
        styleData = {
          rangeLeft: `${lowerPct}%`,
          rangeWidth: `${rangePct}%`
        };
      }

      // Format feature importance
      if (Object.keys(featureImportance).length > 0) {
        formattedData.featureImportance = Object.entries(featureImportance)
          .slice(0, 5)
          .map(([feature, importance]) => ({
            feature: feature.replace(/_/g, ' '),
            importance: typeof importance === 'number' ? importance.toFixed(1) : '0',
            widthPct: `${typeof importance === 'number' ? importance : 0}%`
          }));
      }
    }

    return {
      data: {
        prediction,
        chartId,
        hasData: !!prediction && (prediction.predicted_price || prediction.data?.predicted_price),
        formatted: formattedData,
        styles: styleData
      }
    };
  }
</loader>

<div class="result-chart bg-white rounded-lg shadow p-6">
  <h3 class="text-lg font-semibold text-gray-900 mb-4">Prediction Results</h3>

  {loadResultChart.data.hasData ?
    <div>
      <!-- Prediction Summary -->
      <div class="mb-6 p-4 bg-blue-50 rounded-lg">
        <div class="flex items-center justify-between">
          <div>
            <p class="text-sm text-blue-600 font-medium">Estimated Price</p>
            <p class="text-3xl font-bold text-blue-900">
              {loadResultChart.data.formatted.formattedPrice}
            </p>
            <p class="text-sm text-blue-600 mt-1">
              Price per {loadResultChart.data.formatted.priceLabel}: {loadResultChart.data.formatted.formattedPricePerSqm}
            </p>
          </div>
          <div class="text-right">
            <p class="text-sm text-gray-600">Confidence Range</p>
            <p class="text-lg font-semibold text-gray-900">
              {loadResultChart.data.formatted.confidenceRange}
            </p>
            <p class="text-xs text-gray-500 mt-1">95% confidence</p>
          </div>
        </div>
      </div>

      <!-- Confidence Visualization -->
      <div class="mb-6">
        <h4 class="text-md font-medium text-gray-700 mb-3">Price Range Visualization</h4>
        <div class="relative h-12 bg-gray-200 rounded-full overflow-hidden">
          <div class="absolute h-full bg-gradient-to-r from-green-400 via-blue-400 to-green-400 rounded-full"
            style="left: {loadResultChart.data.styles.rangeLeft}; width: {loadResultChart.data.styles.rangeWidth};">
          </div>
          <div class="absolute top-1/2 transform -translate-y-1/2"
            style="left: 50%; transform: translateX(-50%) translateY(-50%);">
            <div class="w-4 h-4 bg-white border-4 border-blue-600 rounded-full"></div>
            <p class="text-xs font-semibold text-gray-900 mt-1">Estimated</p>
          </div>
        </div>
        <div class="flex justify-between mt-2 text-xs text-gray-600">
          <span>{loadResultChart.data.formatted.formattedLowerBound}</span>
          <span>{loadResultChart.data.formatted.formattedUpperBound}</span>
        </div>
      </div>

      <!-- Feature Importance -->
      {loadResultChart.data.formatted.hasFeatureImportance ?
        <div class="mb-6">
          <h4 class="text-md font-medium text-gray-700 mb-3">Key Factors Affecting Price</h4>
          <div class="space-y-2">
            {loadResultChart.data.formatted.featureImportance.map(item =>
              <div class="flex items-center">
                <div class="flex-1">
                  <div class="flex justify-between items-center mb-1">
                    <span class="text-sm text-gray-700 capitalize">{item.feature}</span>
                    <span class="text-sm font-medium text-gray-900">{item.importance}%</span>
                  </div>
                  <div class="w-full bg-gray-200 rounded-full h-2">
                    <div class="bg-blue-600 h-2 rounded-full transition-all duration-500"
                      style="width: {item.widthPct};"></div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
        : <div></div>
      }

      <!-- Chart Canvas -->
      <div>
        <h4 class="text-md font-medium text-gray-700 mb-3">Price Distribution</h4>
        <div class="chart-container" style="height: 250px; position: relative;">
          <canvas id="chart-canvas-{loadResultChart.data.chartId}"></canvas>
        </div>
      </div>
    </div>
  :
    <div class="text-center py-8 text-gray-500">
      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>
      <p class="mt-2">No prediction data available</p>
      <p class="text-sm">Please submit the form to see prediction results</p>
    </div>
  }
</div>

<script client>
  // Global chart registry to prevent duplicates
  window.resultCharts = window.resultCharts || {};

  document.addEventListener('DOMContentLoaded', function() {
    const resultData = PureMix.data?.loadResultChart?.data;
    const chartId = resultData?.chartId;
    const canvas = chartId ? document.getElementById(`chart-canvas-${chartId}`) : null;
    const hasData = resultData?.hasData;
    const prediction = resultData?.prediction;

    // Destroy existing chart for this ID if it exists
    if (chartId && window.resultCharts[chartId]) {
      window.resultCharts[chartId].destroy();
      delete window.resultCharts[chartId];
    }

    if (canvas && hasData && prediction) {
      const ctx = canvas.getContext('2d');

      // Extract values with fallback for nested structures
      const predictedPrice = prediction.predicted_price || prediction.data?.predicted_price || 0;
      const confidenceInterval = prediction.confidence_interval || prediction.data?.confidence_interval || { lower: 0, upper: 0 };

      // Create a distribution chart
      const labels = ['Min Estimate', 'Lower 95%', 'Predicted', 'Upper 95%', 'Max Estimate'];
      const data = [
        confidenceInterval.lower * 0.9,
        confidenceInterval.lower,
        predictedPrice,
        confidenceInterval.upper,
        confidenceInterval.upper * 1.1
      ];

      const config = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Price Range',
            data: data,
            backgroundColor: [
              'rgba(156, 163, 175, 0.5)',
              'rgba(59, 130, 246, 0.5)',
              'rgba(16, 185, 129, 0.5)',
              'rgba(59, 130, 246, 0.5)',
              'rgba(156, 163, 175, 0.5)'
            ],
            borderColor: [
              'rgb(156, 163, 175)',
              'rgb(59, 130, 246)',
              'rgb(16, 185, 129)',
              'rgb(59, 130, 246)',
              'rgb(156, 163, 175)'
            ],
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const value = new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    maximumFractionDigits: 0
                  }).format(context.parsed.y);
                  return context.label + ': ' + value;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              ticks: {
                callback: function(value) {
                  return '$' + (value / 1000) + 'k';
                }
              }
            }
          }
        }
      };

      // Store chart instance globally
      window.resultCharts[chartId] = new Chart(ctx, config);
    }
  });
</script>
